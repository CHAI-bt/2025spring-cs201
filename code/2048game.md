# 2048游戏

## Q1. Game 2048

请帮我写一个python程序，就是在Mac terminal中可以运行的 2048 游戏，可以没有GUI。

目标设为 2048，但在达到 2048 后不会自动结束，你可以继续游戏争取更高的数字：



<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250219221003001.png" alt="image-20250219221003001" style="zoom:50%;" />



```python
#!/usr/bin/env python3
import random
import os
import sys

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # 清屏
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def main():
    board = init_board()
    has_printed_win = False  # 避免重复打印获胜消息
    print_board(board)
    while True:
        move = input("请输入移动方向 (w/a/s/d)，或 q 退出：").lower().strip()
        if move not in ['w', 'a', 's', 'd', 'q']:
            continue
        if move == 'q':
            print("退出游戏。")
            sys.exit(0)

        if move == 'w':
            new_board = move_up(board)
        elif move == 'a':
            new_board = move_left(board)
        elif move == 's':
            new_board = move_down(board)
        elif move == 'd':
            new_board = move_right(board)

        if not boards_equal(board, new_board):
            board = new_board
            add_random_tile(board)
        else:
            print("无效移动！")
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("恭喜你达到了 2048！当然，如果能合成更大的数字就更好！")
            has_printed_win = True

        if not can_move(board):
            print("游戏结束，无法移动！")
            break

if __name__ == "__main__":
    main()
```

**使用说明**

1. 将代码保存为文件（例如 `game_2048.py`）。
2. 在终端中执行 `chmod +x game_2048.py` 给予执行权限。
3. 运行 `./game_2048.py` 启动游戏。

游戏中输入 `w/a/s/d` 分别控制上、左、下、右移动，输入 `q` 退出。达到 2048 后会显示提示，但你仍可继续游戏，挑战更高的分数。



## Q2.Auto 2048

帮我做一个升级版本，就是自动演示上下左右移动的2048游戏



下面是一份自动演示版 2048 游戏的 Python 代码，运行时会自动随机选择上、下、左、右移动，并在终端中展示移动过程。你可以直接在 Mac Terminal 中运行该脚本：

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    # 以 10% 的概率生成 4，其余生成 2
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # 清屏
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    # 去除所有零值
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        # 若相邻数字相等，则合并
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    # 补0使长度固定
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    new_board = []
    for row in board:
        new_board.append(slide_and_merge(row))
    return new_board

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    # 若有空格则肯定能移动
    for row in board:
        if 0 in row:
            return True
    # 检查水平和垂直是否有可合并的数字
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def main():
    board = init_board()
    has_printed_win = False  # 避免重复打印获胜消息
    print_board(board)
    while True:
        if not can_move(board):
            print("游戏结束，无法移动！")
            break

        # 自动随机选择一个方向
        move = random.choice(['w', 'a', 's', 'd'])
        print(f"自动移动：{move}")
        if move == 'w':
            new_board = move_up(board)
        elif move == 'a':
            new_board = move_left(board)
        elif move == 's':
            new_board = move_down(board)
        elif move == 'd':
            new_board = move_right(board)

        if not boards_equal(board, new_board):
            board = new_board
            add_random_tile(board)
        else:
            print("无效移动，尝试其他方向。")

        print_board(board)
        if reached_target(board) and not has_printed_win:
            print("已达到 2048！继续自动移动以获得更高分数。")
            has_printed_win = True

        time.sleep(0.5)  # 延时0.5秒，便于观察演示效果

if __name__ == "__main__":
    main()
```

---

**使用说明**

1. 将上述代码保存为文件（例如 `auto_2048.py`）。
2. 在终端中运行命令 `chmod +x auto_2048.py` 赋予执行权限。
3. 运行 `./auto_2048.py` 启动自动演示。

程序将自动随机选择上、下、左、右方向进行移动，并以 0.5 秒的间隔更新显示。你可以通过修改 `time.sleep` 的延时参数来调整演示速度。





## Q3.`auto_2048_intelligent.py`

能智能些吗？刚运行auto_2048，才累积到128，就游戏结束无法移动了。



下面是一份升级版自动演示 2048 游戏代码，加入了简单的启发式策略。程序会对四个方向的移动进行模拟，选择能使空格最多的那一步，从而尽量延长游戏时间，避免早期卡死。你可以直接在 Mac Terminal 下运行该脚本：

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # 清屏
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -1
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = count_empty(new_board)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("游戏结束，无法移动！")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("没有有效移动，游戏结束！")
            break

        print(f"自动移动：{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("已达到 2048！继续自动移动以获得更高分数。")
            has_printed_win = True

        time.sleep(0.5)

if __name__ == "__main__":
    main()
```

---

使用说明

1. 将上述代码保存为文件（例如 `auto_2048_intelligent.py`）。
2. 在终端中执行 `chmod +x auto_2048_intelligent.py` 赋予执行权限。
3. 运行 `./auto_2048_intelligent.py` 启动自动演示。

程序会自动选择四个方向中使空格最多的移动方向，尽量保持棋盘宽松，帮助你累积到更高的分数。你也可以调整 `time.sleep` 延时参数来观察移动过程。



## Q4.auto_2048.ai

还是不够智能，到128就结束了



下面是一份升级版自动演示 2048 游戏代码，采用了简单的“1 层期望搜索（expectimax）”策略和启发式评估函数，从而尽可能选择对局面更有利的移动。该代码在模拟每个可能移动后，对随机新增块进行平均评估，然后选择评分最高的移动方向，从而延长游戏时间，争取更高分数：

```python
#!/usr/bin/env python3
import random
import os
import sys
import time
import copy

BOARD_SIZE = 4
TARGET = 2048

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # Mac/Linux 下清屏
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    # 去除0值
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    transposed = transpose(board)
    moved = move_left(transposed)
    return transpose(moved)

def move_down(board):
    transposed = transpose(board)
    moved = move_right(transposed)
    return transpose(moved)

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j+1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i+1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def evaluate_board(board):
    """
    一个简单的评估函数，综合考虑：
    1. 空格数：空格越多越好（乘以较大权重）
    2. 最大数字是否在角落：在角落奖励
    3. 行列单调性：如果整行或整列是单调的，给予一定奖励
    """
    score = count_empty(board) * 100

    max_tile = max(max(row) for row in board)
    # 如果最大数字在角落，则奖励
    corners = [board[0][0], board[0][BOARD_SIZE-1], board[BOARD_SIZE-1][0], board[BOARD_SIZE-1][BOARD_SIZE-1]]
    if max_tile in corners:
        score += max_tile * 10

    # 行单调性奖励
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row) * 0.1
    # 列单调性奖励
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col) * 0.1

    return score

def expectimax_value(board):
    """
    1层期望搜索：
    对当前局面，模拟在每个空格上随机生成2（概率0.9）或4（概率0.1），
    返回平均评估得分。
    """
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return evaluate_board(board)
    total = 0
    for (i, j) in empty:
        board2 = copy.deepcopy(board)
        board2[i][j] = 2
        score2 = evaluate_board(board2)
        board4 = copy.deepcopy(board)
        board4[i][j] = 4
        score4 = evaluate_board(board4)
        total += 0.9 * score2 + 0.1 * score4
    return total / len(empty)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        # 使用1层期望搜索的评估
        score = expectimax_value(new_board)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("游戏结束，无法移动！")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("没有有效移动，游戏结束！")
            break

        print(f"自动移动：{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("已达到 2048！继续自动移动以获得更高分数。")
            has_printed_win = True

        time.sleep(0.3)

if __name__ == "__main__":
    main()
```

---

### 使用说明

1. 将上述代码保存为文件（例如 `auto_2048_ai.py`）。
2. 在终端中执行 `chmod +x auto_2048_ai.py` 赋予执行权限。
3. 运行 `./auto_2048_ai.py` 启动自动演示。

此版本采用了简单的启发式评估和1层期望搜索：  
• 每个可能的移动后，程序会模拟在所有空位上新增数字（2 和 4）后计算平均评估分数；  
• 评估函数综合考虑了空格数量、最大数字是否处于角落以及行列的单调性。  

这样有助于程序选择更加“智能”的移动方向，争取获得更高的分数而不是早早卡死。  
请根据需要调整权重和延时（time.sleep）参数以获得最佳效果。





## Q5.`auto_2048_expectimax.py`

还是不够智能，到256就结束了



下面这份代码使用了多层（深度 3）期望搜索（expectimax），并在评估函数中加入了角落权重、空格奖励以及行列单调性奖励，以期使 AI 在选择移动时更“聪明”，尽量避免早期卡死。请注意，由于搜索深度增加，运行速度可能会变慢一些，但通常能在 4×4 棋盘上接受。

```python
#!/usr/bin/env python3
import random
import os
import sys
import time
import copy

BOARD_SIZE = 4
TARGET = 2048
SEARCH_DEPTH = 3  # 增加搜索深度

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')  # Mac/Linux 下清屏
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i + 1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j + 1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i + 1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def evaluate_board(board):
    score = 0
    # 奖励空格
    empty = sum(row.count(0) for row in board)
    score += empty * 100

    # 使用一个预设的权重矩阵，鼓励最大值位于角落（这里采用蛇形布局）
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            score += board[i][j] * weights[i][j]

    # 奖励行单调性
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row)
    # 奖励列单调性
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col)

    return score

def expectimax(board, depth, is_player):
    if depth == 0 or not can_move(board):
        return evaluate_board(board)
    if is_player:
        best = -float('inf')
        # 玩家节点：尝试所有四个方向
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            value = expectimax(new_board, depth, False)
            best = max(best, value)
        return best if best != -float('inf') else evaluate_board(board)
    else:
        # 概率节点：模拟在所有空格上随机出现 2 或 4
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            return evaluate_board(board)
        total = 0.0
        for (i, j) in empty:
            for tile, prob in [(2, 0.9), (4, 0.1)]:
                new_board = copy.deepcopy(board)
                new_board[i][j] = tile
                total += prob * expectimax(new_board, depth - 1, True)
        return total / len(empty)

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        # 此处使用多层期望搜索，后续节点为概率节点
        score = expectimax(new_board, SEARCH_DEPTH, False)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("游戏结束，无法移动！")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("没有有效移动，游戏结束！")
            break

        print(f"自动移动：{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("已达到 2048！继续自动移动以获得更高分数。")
            has_printed_win = True

        time.sleep(0.2)

if __name__ == "__main__":
    main()
```

---

### 使用说明

1. 将上述代码保存为文件（例如 `auto_2048_expectimax.py`）。
2. 在终端中运行命令 `chmod +x auto_2048_expectimax.py` 赋予执行权限。
3. 运行 `./auto_2048_expectimax.py` 启动自动演示。

此版本在玩家决策节点中采用了 3 层期望搜索，在概率节点上模拟所有可能的随机新增块，并结合改进的评估函数，以期延长游戏时间、尽量避免早期陷入死局。你可以根据需要调整 SEARCH_DEPTH、权重矩阵或延时参数（time.sleep）以获得更佳效果。







## Q6.`auto_2048_optimized.py`

运行太慢了，能优化吗？并且能取得2048结果或者更高



下面是经过优化后的版本，主要做了以下改进：

<img src="https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250219230024196.png" alt="image-20250219230024196" style="zoom:50%;" />



• 用局部函数替换 copy.deepcopy，改用 [row[:] for row in board] 进行浅拷贝  
• 增加了缓存（转置表）来保存 expectimax 计算结果，避免重复搜索，从而提升搜索速度  
• 保持 SEARCH_DEPTH 为 3（可根据性能和效果调整）

该版本在 4×4 棋盘上运行速度有较大提升，并能更智能地选择移动，从而有望达到 2048 甚至更高分数。

```python
#!/usr/bin/env python3
import random
import os
import sys
import time

BOARD_SIZE = 4
TARGET = 2048
SEARCH_DEPTH = 3  # 搜索深度

# 缓存 expectimax 计算结果
cache = {}

def board_to_key(board):
    return tuple(tuple(row) for row in board)

def init_board():
    board = [[0] * BOARD_SIZE for _ in range(BOARD_SIZE)]
    add_random_tile(board)
    add_random_tile(board)
    return board

def add_random_tile(board):
    empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
    if not empty:
        return
    i, j = random.choice(empty)
    board[i][j] = 4 if random.random() < 0.1 else 2

def print_board(board):
    os.system('clear')
    print("-" * (BOARD_SIZE * 7 + 1))
    for row in board:
        print("|", end="")
        for num in row:
            if num == 0:
                print("      |", end="")
            else:
                print(f"{num:^6}|", end="")
        print()
        print("-" * (BOARD_SIZE * 7 + 1))

def slide_and_merge(line):
    new_line = [num for num in line if num != 0]
    merged_line = []
    skip = False
    for i in range(len(new_line)):
        if skip:
            skip = False
            continue
        if i + 1 < len(new_line) and new_line[i] == new_line[i+1]:
            merged_line.append(new_line[i] * 2)
            skip = True
        else:
            merged_line.append(new_line[i])
    merged_line += [0] * (BOARD_SIZE - len(merged_line))
    return merged_line

def move_left(board):
    return [slide_and_merge(row) for row in board]

def reverse(board):
    return [list(reversed(row)) for row in board]

def transpose(board):
    return [list(row) for row in zip(*board)]

def move_right(board):
    return reverse(move_left(reverse(board)))

def move_up(board):
    return transpose(move_left(transpose(board)))

def move_down(board):
    return transpose(move_right(transpose(board)))

def boards_equal(b1, b2):
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if b1[i][j] != b2[i][j]:
                return False
    return True

def can_move(board):
    for row in board:
        if 0 in row:
            return True
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            if j + 1 < BOARD_SIZE and board[i][j] == board[i][j+1]:
                return True
            if i + 1 < BOARD_SIZE and board[i][j] == board[i+1][j]:
                return True
    return False

def reached_target(board):
    for row in board:
        if any(num >= TARGET for num in row):
            return True
    return False

def count_empty(board):
    return sum(row.count(0) for row in board)

def evaluate_board(board):
    score = 0
    # 奖励空格
    empty = count_empty(board)
    score += empty * 100

    # 权重矩阵（蛇形布局），鼓励最大数字位于角落
    weights = [
        [65536, 32768, 16384, 8192],
        [512,   1024,  2048,  4096],
        [256,    512,  1024,  2048],
        [128,    256,   512,  1024]
    ]
    for i in range(BOARD_SIZE):
        for j in range(BOARD_SIZE):
            score += board[i][j] * weights[i][j]

    # 奖励行单调性
    for row in board:
        if all(row[i] >= row[i+1] for i in range(len(row)-1)) or all(row[i] <= row[i+1] for i in range(len(row)-1)):
            score += sum(row)
    # 奖励列单调性
    for col in zip(*board):
        if all(col[i] >= col[i+1] for i in range(len(col)-1)) or all(col[i] <= col[i+1] for i in range(len(col)-1)):
            score += sum(col)
    return score

def expectimax(board, depth, is_player):
    key = (board_to_key(board), depth, is_player)
    if key in cache:
        return cache[key]
    if depth == 0 or not can_move(board):
        val = evaluate_board(board)
        cache[key] = val
        return val
    if is_player:
        best = -float('inf')
        for move_func in [move_up, move_down, move_left, move_right]:
            new_board = move_func(board)
            if boards_equal(board, new_board):
                continue
            val = expectimax(new_board, depth, False)
            best = max(best, val)
        result = best if best != -float('inf') else evaluate_board(board)
    else:
        empty = [(i, j) for i in range(BOARD_SIZE) for j in range(BOARD_SIZE) if board[i][j] == 0]
        if not empty:
            result = evaluate_board(board)
        else:
            total = 0.0
            for (i, j) in empty:
                for tile, prob in [(2, 0.9), (4, 0.1)]:
                    board_copy = [row[:] for row in board]
                    board_copy[i][j] = tile
                    total += prob * expectimax(board_copy, depth - 1, True)
            result = total / len(empty)
    cache[key] = result
    return result

def choose_best_move(board):
    moves = {
        'w': move_up,
        'a': move_left,
        's': move_down,
        'd': move_right
    }
    best_move = None
    best_score = -float('inf')
    best_new_board = None
    for move, func in moves.items():
        new_board = func(board)
        if boards_equal(board, new_board):
            continue
        score = expectimax(new_board, SEARCH_DEPTH, False)
        if score > best_score:
            best_score = score
            best_move = move
            best_new_board = new_board
    return best_move, best_new_board

def main():
    board = init_board()
    has_printed_win = False
    print_board(board)
    while True:
        if not can_move(board):
            print("游戏结束，无法移动！")
            break

        move, new_board = choose_best_move(board)
        if move is None:
            print("没有有效移动，游戏结束！")
            break

        print(f"自动移动：{move}")
        board = new_board
        add_random_tile(board)
        print_board(board)

        if reached_target(board) and not has_printed_win:
            print("已达到 2048！继续自动移动以获得更高分数。")
            has_printed_win = True

        time.sleep(0.2)

if __name__ == "__main__":
    main()
```

---

### 使用说明

1. 将上述代码保存为文件（例如 `auto_2048_optimized.py`）。  
2. 在终端中运行 `chmod +x auto_2048_optimized.py` 赋予执行权限。  
3. 运行 `./auto_2048_optimized.py` 启动自动演示。

通过缓存和改进的拷贝方式，此版本在保证一定搜索深度的前提下速度有明显提升。希望这版能够更稳定地达到 2048 或更高分数，同时运行速度更快。



