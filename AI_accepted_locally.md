# AI Accepted locally

Updated 1949 GMT+8 Feb 15 2025

2025 spring, Complied by Hongfei Yan



# DeepSeek-R1-Distill-Qwen-32B-Q4_K_M.gguf

**Mac Studio**

Processor Apple M1 Ultra @ 3.21 GHz,20 核，48核GPU，64GB 内存。

统一内存架构(UMA)让CPU和GPU共享同一内存吃，无需数据复制。

OS macOS 15.3 (Build 24D60), AI Framework	Core ML, AI Backedn	GPU.



## 27300:模型整理

http://cs101.openjudge.cn/practice/27300/

深度学习模型（尤其是大模型）是近两年计算机学术和业界热门的研究方向。每个模型可以用 “模型名称-参数量” 命名，其中参数量的单位会使用两种：M，即百万；B，即十亿。同一个模型通常有多个不同参数的版本。例如，Bert-110M，Bert-340M 分别代表参数量为 1.1 亿和 3.4 亿的 Bert 模型，GPT3-350M，GPT3-1.3B 和 GPT3-175B 分别代表参数量为 3.5亿，13亿和 1750 亿的 GPT3 模型。参数量的数字部分取值在 [1, 1000) 区间（一个 8 亿参数的模型表示为 800M 而非 0.8B，10 亿参数的模型表示为 1B 而非 1000M）。计算机专业的学生小 A 从网上收集了一份模型的列表，他需要将它们按照名称归类排序，并且同一个模型的参数量从小到大排序，生成 “模型名称: 参数量1, 参数量2, ...” 的列表。请你帮他写一个程序实现。

**输入**

第一行为一个正整数 n（n <= 1000），表示有 n 个待整理的模型。

接下来 n 行，每行一个 “模型名称-参数量” 的字符串。模型名称是字母和数字的混合。

**输出**

每行一个 “模型名称: 参数量1, 参数量2, ...” 的字符串，符号均为英文符号，模型名称按字典序排列，参数量按从小到大排序。

样例输入

```
5
GPT-1.3B
Bert-340M
GPT-350M
Bert-110M
GPT-175B
```

样例输出

```
Bert: 110M, 340M
GPT: 350M, 1.3B, 175B
```

提示

tags: string, sort

来源

2023fall zyn



lmstudio-community/DeepSeek-R1-Distill-Qwen-32B-GGUF/DeepSeek-R1-Distill-Qwen-32B-Q4_K_M.gguf

![image-20250215195533681](https://raw.githubusercontent.com/GMyhf/img/main/img/image-20250215195533681.png)



> <think>
> 好的，我现在需要解决这个问题。让我仔细读题目。
>
> 问题描述是这样的：我们有一个列表，里面包含多个模型的名称和参数量，每个模型用“模型名称-参数量”表示。参数量可能以M或B为单位，比如Bert-110M代表1.1亿参数，而GPT3-175B则代表1750亿参数。
>
> 我们的任务是将这些模型按名称分类，并对同一个模型的不同参数版本进行排序，最后输出格式为“模型名称: 参数量1, 参数量2, ...”，其中模型名称按照字典序排列，每个模型的参数量从低到高排序。
>
> 首先，我得考虑如何处理输入数据。输入的第一行是一个整数n，表示接下来有n个模型字符串。然后是n行每行一个模型名称和参数量。
>
> 接下来，我需要将这些模型按名称分组。比如，所有以“Bert”开头的归为一组，以“GPT”开头的归另一组等等。这可能涉及到分割字符串，找到模型名称部分。
>
> 对于每个模型字符串，我们可以将其拆分为两个部分：模型名称和参数量。例如，“Bert-340M”拆分成“Bert”和“340M”。
>
> 接下来，我需要对同一个模型的不同参数版本进行排序。这里的关键是比较不同单位的数值大小，并将它们转换为一个统一的标准来比较。
>
> 如何处理参数量呢？比如，110M等于1.1亿，而1.3B等于13亿。因此，在比较时，需要将所有参数量都转换为相同的单位（如M或B）进行数值比较，然后再按照从小到大的顺序排列。
>
> 我的思路是：
>
> 1. 将每个模型的名称和参数部分分开。
> 2. 对于每个参数部分，提取数字部分和单位，并将其转换为统一的数值进行比较。比如，将所有参数量都转换成M或者B的数值。
> 3. 按照模型名称字典序排序，同一模型下按参数大小排序。
>
> 首先，我需要处理每个模型字符串，分割出模型名称和参数部分。例如，“GPT-1.3B”会被分成“GPT”和“1.3B”。
>
> 接下来，对于参数部分，比如“1.3B”，我需要将其转换为数值。这可能涉及到检查单位是M还是B，并相应地乘以1e6或1e9。
>
> 比如：
> - 110M → 110,000,000（或者将所有单位统一为M，那么1.3B就是1300M）
> - 340M → 340,000,000
> - 175B → 175,000,000,000
>
> 但是，在比较大小时，可能需要将所有参数转换为同一个单位进行数值比较。比如，统一转换为以M为单位：
>
> 那么，“1.3B”等于1300M，“175B”等于175000M。
>
> 这样，我们可以对每个参数的数值进行排序，然后再将其转换回原来的格式输出。
>
> 接下来，我需要处理输入数据，并将模型分组。可以使用一个字典来存储模型名称作为键，对应的参数列表为值。例如：
>
> {
>     'Bert': ['110M', '340M'],
>     'GPT': ['350M', '1.3B', '175B']
> }
>
> 然后，对每个模型的参数列表进行排序，根据它们转换后的数值大小。
>
> 具体的步骤如下：
>
> 1. 读取输入n。
> 2. 对于接下来的每一行：
>    a. 分割字符串为模型名称和参数量部分。
>    b. 提取参数量中的数值和单位。
> 3. 将所有参数量转换为统一的数值（比如，转换为M）以便比较大小，并保持原始格式用于输出。
> 4. 按照模型名称字典序排序。
> 5. 对每个模型下的参数列表按照数值从小到大排序。
> 6. 最后，按要求的格式输出。
>
> 现在，具体如何实现呢？
>
> 首先，分割字符串。比如，“GPT-175B”可以拆分为“GPT”和“175B”。我们可以用split('-')来分割，得到两部分。
>
> 然后处理参数量部分。例如，对于“340M”，提取数值340，单位是M；同样地，“1.3B”则为1.3和B。
>
> 接下来，将这些转换成统一的数值进行比较。比如：
>
> - 对于M，乘以1e6（或者保持原样）。
> - 对于B，乘以1e9。
>
> 但是，在处理过程中可能需要将参数量转换为相同的单位来比较大小。例如，把所有参数都转换为M：
>
> 那么，“340M”就是340, “1.3B”是1300M（因为1.3 * 1000 = 1300）。
>
> 或者，另一种方法是将它们统一为以亿为单位。例如，M代表百万，即千分之一亿；而B代表十亿。这可能更容易处理。
>
> 例如：
>
> - “340M”等于0.34亿。
> - “1.3B”等于13亿。
> - “175B”等于1750亿。
>
> 然后，将这些数值进行比较，排序。
>
> 但是，在实际操作中，如何从参数字符串提取数值和单位呢？可以使用正则表达式来匹配数字部分和单位。例如：
>
> 对于每个参数字符串，比如“1.3B”，可以用正则表达式找到数字部分（包括小数点）以及后面的字母部分（M或B）。
>
> 在Python中，可以使用re模块的split函数或者search函数来提取这些信息。例如：
>
> import re
>
> s = '1.3B'
> match = re.match(r'(\d+\.?\d*)([A-Za-z]+)', s)
> if match:
>     num_str, unit = match.groups()
>     num = float(num_str)
>
> 这样，num就是1.3，unit是'B'。
>
> 接下来，将这个数值转换为统一的单位。假设我们选择以M为单位：
>
> 如果单位是B，那么乘以 1000（因为1B=1000M）。例如：
>
> if unit == 'B':
>     num_m = num * 1000
> else:
>     num_m = num
>
> 这样，“1.3B”会变成1300M，“340M”保持不变，而“175B”则是175,000 M。
>
> 然后，我们可以将每个参数量转换为对应的数值（以M为单位），以便比较大小。排序时按照这个数值进行升序排列。
>
> 但是，这可能有问题吗？比如，如果参数量是800M，那么它应该表示为“800M”而不是“0.8B”。所以，在输出的时候，需要根据原始数据的格式来呈现。
>
> 因此，在处理过程中，我们需要保留原始的字符串形式，同时计算出它们的数值以便排序。
>
> 这可能意味着，在字典中存储模型名称对应的参数列表时，每个元素是一个元组（数值，原字符串）。这样在排序时可以比较数值部分，输出时则使用原字符串。
>
> 例如：
>
> 对于“Bert-110M”和“Bert-340M”，它们会被转换为数值110M和340M，并按升序排列，输出“110M, 340M”。
>
> 而“GPT-350M”, “GPT-1.3B”, “GPT-175B”对应的数值分别是350M，1300M（即1.3B），和175000M。排序后是350M < 1300M < 175000M，所以输出顺序为“350M, 1.3B, 175B”。
>
> 这样，处理起来更方便。
>
> 总结一下步骤：
>
> 1. 读取输入n。
> 2. 初始化一个字典，用于存储每个模型的参数列表。键是模型名称，值是一个列表，其中每个元素是元组（数值，原字符串）。
> 3. 遍历每一行输入：
>    a. 分割成模型名称和参数部分。
>    b. 提取参数中的数值和单位。
>    c. 计算对应的数值（以M为单位：B转换为1000倍的M）。
>    d. 将元组（数值，原字符串）添加到字典中对应模型下的列表里。
> 4. 对每个模型下的参数列表进行排序。排序的依据是数值部分，升序排列。
> 5. 按照模型名称字典序对字典中的键进行排序，并生成输出。
> 6. 输出每行的结果：模型名称: 参数1, 参数2, ...
>
> 现在，如何实现这些步骤呢？
>
> 首先，在Python中：
>
> 读取n:
>
> n = int(input())
>
> 然后，创建一个空字典：
>
> model_dict = {}
>
> 然后，循环n次：
>
> for _ in range(n):
>     model_str = input().strip()
>     name_part, param_part = model_str.split('-')
>
> 这会将字符串分割为模型名称和参数部分。例如，“Bert-340M”会被拆分为“Bert”和“340M”。
>
> 接下来，处理param_part：
>
> 使用正则表达式提取数值和单位：
>
> import re
>
> match = re.match(r'^(\d+\.?\d*)([A-Za-z]+)$', param_part)
> if not match:
>     # 可能会有错误的情况？比如格式不正确？
>     pass
> else:
>     num_str, unit = match.groups()
>     num = float(num_str)
>
> 然后，计算数值：
>
> if unit == 'B':
>     num_m = num * 1000
> elif unit == 'M':
>     num_m = num
>
> 将参数添加到字典中：
>
> if name_part in model_dict:
>     model_dict[name_part].append( (num_m, param_part) )
> else:
>     model_dict[name_part] = [ (num_m, param_part) ]
>
> 处理完所有输入后，对每个模型的参数列表进行排序。因为我们需要按照数值从小到大排列：
>
> for name in model_dict:
>     # 按元组的第一个元素（数值）排序
>     model_dict[name].sort(key=lambda x: x[0])
>
> 接下来，将字典中的键按字典序排序，并生成输出。
>
> sorted_names = sorted(model_dict.keys())
>
> 然后，对于每个模型名称：
>
> for name in sorted_names:
>     params = model_dict[name]
>     # 提取原字符串部分
>     param_list = [ p[1] for p in params ]
>     # 拼接字符串
>     output_str = f"{name}: {', '.join(param_list)}"
>     print(output_str)
>
> 这样，就能得到正确的输出。
>
> 但是，我需要测试一下这个逻辑是否正确。比如，样例输入：
>
> 5
>
> GPT-1.3B
>
> Bert-340M
>
> GPT-350M
>
> Bert-110M
>
> GPT-175B
>
> 处理后，字典中的内容应该是：
>
> {
>     'Bert': [ (110, '110M'), (340, '340M') ],
>     'GPT': [ (350, '350M'), 1.3*1000=1300 → ('1.3B'), 175B → 175*1000=175000 M ]
> }
>
> 排序后，每个模型的参数列表顺序正确。
>
> 那么，输出是：
>
> Bert: 110M, 340M
>
> GPT: 350M, 1.3B, 175B
>
> 这与样例输出一致。
>
> 但是，在代码中，处理“1.3B”时会得到num = 1.3，unit='B' → num_m=1300。而另一个参数比如“175B”，num=175→ num_m=175*1000=175,000。
>
> 在排序时，数值分别为：350 < 1300 < 175000 → 正确。
>
> 这样，代码逻辑是正确的。
>
> 那么，接下来编写完整的Python程序：
>
> 读取n，初始化字典，循环处理每行输入，分割模型名称和参数部分，提取数值和单位，计算num_m，存储元组。然后排序，输出。
>
> 需要注意的是，在拆分参数时，可能有多个点吗？比如“1.2.3B”这种情况，但题目中给出的样例都是正确的，所以假设输入是符合规范的。如果没有错误处理，程序可能会遇到问题。但在本题中，可以假设输入是正确的。
>
> 此外，单位只能是M或B吗？根据题目描述，是的。
>
> 那么，编写代码：
>
> import re
>
> n = int(input())
> model_dict = {}
>
> for _ in range(n):
>     model_str = input().strip()
>     name_part, param_part = model_str.split('-')
>     
>     # 提取参数中的数值和单位
>     match = re.match(r'^(\d+\.?\d*)([A-Za-z]+)$', param_part)
>     if not match:
>         continue  # 或者处理错误情况，但题目中假设输入正确
>     
>     num_str, unit = match.groups()
>     num = float(num_str)
>     
>     if unit == 'B':
>         num_m = num * 1000
>     elif unit == 'M':
>         num_m = num
>     else:
>         # 其他情况，但题目中没有说明，可以忽略？
>         continue
>     
>     if name_part not in model_dict:
>         model_dict[name_part] = []
>     model_dict[name_part].append( (num_m, param_part) )
>
> **对每个模型的参数列表按数值排序**
>
> for name in model_dict:
>     model_dict[name].sort(key=lambda x: x[0])
>
> **按字典序输出模型名称，并格式化参数**
>
> sorted_names = sorted(model_dict.keys())
>
> for name in sorted_names:
>     params = [p[1] for p in model_dict[name]]
>     print(f"{name}: {', '.join(params)}")
>
> 测试一下这个代码是否正确处理样例输入：
>
> 输入：
> 5
> GPT-1.3B
> Bert-340M
> GPT-350M
> Bert-110M
> GPT-175B
>
> 运行后的结果应该是：
> Bert: 110M, 340M
> GPT: 350M, 1.3B, 175B
>
> 这与预期一致。
>
> 再考虑边界情况，比如：
>
> n=1，输入“Test-800M”，输出应为“Test: 800M”。
>
> 另一个测试：模型名称有大小写吗？例如，“bert”和“Bert”会被认为是不同的模型。根据题目描述，模型名称由字母和数字组成，所以应该区分大小写。
>
> 比如，输入：
>
> 3
> bert-100M
> Bert-200M
> BERT-300M
>
> 输出会是按字典序排列的三个独立条目。
>
> 此外，参数量可能有小数点，比如“1.5B”→ 1500M。代码中处理为浮点数，所以没有问题。
>
> 综上所述，这个程序应该能够正确处理题目中的各种情况。
> </think>



Thought for 3 minus 35 seconds

```python
import re

n = int(input())
model_dict = {}

for _ in range(n):
    model_str = input().strip()
    name_part, param_part = model_str.split('-')
    
    match = re.match(r'^(\d+\.?\d*)([A-Za-z]+)$', param_part)
    if not match:
        continue
    
    num_str, unit = match.groups()
    num = float(num_str)
    
    if unit == 'B':
        num_m = num * 1000
    elif unit == 'M':
        num_m = num
    
    if name_part not in model_dict:
        model_dict[name_part] = []
    model_dict[name_part].append( (num_m, param_part) )

for name in model_dict:
    model_dict[name].sort(key=lambda x: x[0])

sorted_names = sorted(model_dict.keys())

for name in sorted_names:
    params = [p[1] for p in model_dict[name]]
    print(f"{name}: {', '.join(params)}")
```



